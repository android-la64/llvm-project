; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc --mtriple=loongarch64 -O0 < %s | FileCheck %s

@var = external global i32

define void @func() {
; CHECK-LABEL: func:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addi.d $sp, $sp, -2048
; CHECK-NEXT:    addi.d $sp, $sp, -2048
; CHECK-NEXT:    addi.d $sp, $sp, -16
; CHECK-NEXT:    .cfi_def_cfa_offset 4112
; CHECK-NEXT:    lu12i.w $r5, var
; CHECK-NEXT:    ori $r5, $r5, var
; CHECK-NEXT:    lu32i.d $r5, var
; CHECK-NEXT:    lu52i.d $r5, $r5, var
; CHECK-NEXT:    ld.w $r20, $r5, 0
; CHECK-NEXT:    ld.w $r19, $r5, 0
; CHECK-NEXT:    ld.w $r18, $r5, 0
; CHECK-NEXT:    ld.w $r17, $r5, 0
; CHECK-NEXT:    ld.w $r16, $r5, 0
; CHECK-NEXT:    ld.w $r15, $r5, 0
; CHECK-NEXT:    ld.w $r14, $r5, 0
; CHECK-NEXT:    ld.w $r13, $r5, 0
; CHECK-NEXT:    ld.w $r12, $r5, 0
; CHECK-NEXT:    ld.w $r11, $r5, 0
; CHECK-NEXT:    ld.w $r10, $r5, 0
; CHECK-NEXT:    ld.w $r9, $r5, 0
; CHECK-NEXT:    ld.w $r8, $r5, 0
; CHECK-NEXT:    ld.w $r7, $r5, 0
; CHECK-NEXT:    ld.w $r6, $r5, 0
; CHECK-NEXT:    ld.w $r4, $r5, 0
; CHECK-NEXT:    st.d $r23, $sp, 0
; CHECK-NEXT:    lu12i.w $r23, 1
; CHECK-NEXT:    ori $r23, $r23, 12
; CHECK-NEXT:    add.d $r23, $sp, $r23
; CHECK-NEXT:    st.w $r20, $r23, 0
; CHECK-NEXT:    ld.d $r23, $sp, 0
; CHECK-NEXT:    st.w $r20, $r5, 0
; CHECK-NEXT:    st.w $r19, $r5, 0
; CHECK-NEXT:    st.w $r18, $r5, 0
; CHECK-NEXT:    st.w $r17, $r5, 0
; CHECK-NEXT:    st.w $r16, $r5, 0
; CHECK-NEXT:    st.w $r15, $r5, 0
; CHECK-NEXT:    st.w $r14, $r5, 0
; CHECK-NEXT:    st.w $r13, $r5, 0
; CHECK-NEXT:    st.w $r12, $r5, 0
; CHECK-NEXT:    st.w $r11, $r5, 0
; CHECK-NEXT:    st.w $r10, $r5, 0
; CHECK-NEXT:    st.w $r9, $r5, 0
; CHECK-NEXT:    st.w $r8, $r5, 0
; CHECK-NEXT:    st.w $r7, $r5, 0
; CHECK-NEXT:    st.w $r6, $r5, 0
; CHECK-NEXT:    st.w $r4, $r5, 0
; CHECK-NEXT:    lu12i.w $r4, 1
; CHECK-NEXT:    ori $r4, $r4, 16
; CHECK-NEXT:    add.d $sp, $sp, $r4
; CHECK-NEXT:    jr $ra
  %space = alloca i32, align 4
  %stackspace = alloca[1024 x i32], align 4

  ;; Load values to increase register pressure.
  %v0 = load volatile i32, i32* @var
  %v1 = load volatile i32, i32* @var
  %v2 = load volatile i32, i32* @var
  %v3 = load volatile i32, i32* @var
  %v4 = load volatile i32, i32* @var
  %v5 = load volatile i32, i32* @var
  %v6 = load volatile i32, i32* @var
  %v7 = load volatile i32, i32* @var
  %v8 = load volatile i32, i32* @var
  %v9 = load volatile i32, i32* @var
  %v10 = load volatile i32, i32* @var
  %v11 = load volatile i32, i32* @var
  %v12 = load volatile i32, i32* @var
  %v13 = load volatile i32, i32* @var
  %v14 = load volatile i32, i32* @var
  %v15 = load volatile i32, i32* @var

  ;; Computing a stack-relative values needs an additional register.
  ;; We should get an emergency spill/reload for this.
  store volatile i32 %v0, i32* %space

  ;; store values so they are used.
  store volatile i32 %v0, i32* @var
  store volatile i32 %v1, i32* @var
  store volatile i32 %v2, i32* @var
  store volatile i32 %v3, i32* @var
  store volatile i32 %v4, i32* @var
  store volatile i32 %v5, i32* @var
  store volatile i32 %v6, i32* @var
  store volatile i32 %v7, i32* @var
  store volatile i32 %v8, i32* @var
  store volatile i32 %v9, i32* @var
  store volatile i32 %v10, i32* @var
  store volatile i32 %v11, i32* @var
  store volatile i32 %v12, i32* @var
  store volatile i32 %v13, i32* @var
  store volatile i32 %v14, i32* @var
  store volatile i32 %v15, i32* @var

  ret void
}
